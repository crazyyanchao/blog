---
title: 常用CYPHER查询（二）
tags: [ONgDB,Cypher]
author: Yc-Ma
show_author_profile: true
key: 2020-06-16-常用CYPHER查询（二）
pageview: true
---

Here's the table of contents:
1. TOC
{:toc}

### 删除节点与关系
```
match p=(n:虚拟账号ID)-[r]-(m) where n.name=~'.*name_id_.*' delete n,r;
match p=(n:虚拟账号ID)-[r]-(m) where n.name=~'.*NoName_id_.*' delete n,r;
MATCH (n:绰号)-[r:拥有]-(大富豪) DELETE n,r
MATCH p=(n:Son {name:'Lang'})-[r]-(m:Lang {name:'Van'}) DELETE p;
MATCH p=(n:测试事件)-[]-() DELETE p;
MATCH p=(n {title:'Apollo 13'})-[r]-() DELETE n,r
MATCH (n:测试事件:人)-[r:成员]-(m:组织:测试事件) DELETE r; // 删除关系
MATCH (n:事 {name:'2'})-[r:关键词]-(m:物 {name:'专题1468'}) DELETE r; // 只是删除了关系
MATCH (n:事 {name:'2'})-[r:参与事件]-(m:人 {name:'Godfather_683'}) DELETE r;// 只是删除了关系
match(n:事 {name:'2'}) delete n;	//删除了节点

MATCH (n:绰号)-[r:拥有]-(大富豪) DELETE n,r

// 删除节点（删除时知识图谱全是独立的实体节点没有关系，如果存在关系必须先删除关系）
match(n) return n;

// 删除所有节点和关系（OPTIONAL MATCH语句用于搜索模式中描述的匹配项，对于找不到的项，用null代替）
match(n:Lbael) match (n)-[r]-() DELETE n,r

MATCH (n)
OPTIONAL MATCH (n)-[r]-()
DELETE n,r

// 刪除人标签下的节点和关系
MATCH (n:人)
OPTIONAL MATCH (n:人)-[r]-()
DELETE n,r
```

### 标签下属性等于查询
```
Match (n:人) where n.姓名='李泽钜' return n
```
### 查询所有节点
```
match(n) return n;
```
### 通过关系类型查询-过滤与青海省有隶属关系的市
```
MATCH (省 { NAME:'青海省' })<-[:隶属关系]-(市) RETURN 市;
```
### 关联节点查询
```
MATCH (省 { NAME:'青海省' })--(市) RETURN 市.NAME;
```
### 查询标签
```
MATCH (n:地 { NAME:'青海省' })--(m:市) RETURN m;
```
### 属性全等查询【节点merge也使用这种方式】
```
match (n:地 {NAME:"青海省"}) return n;
```
### 测试语句
```
match( p1:市 {NAME:"西宁市"} )-[rel:隶属关系]->(p2) return p2.NAME
测试查询语句：
MATCH (组织 { NAME:'儿童' })<-[:老师]-(n) RETURN n;
MATCH (组织 { NAME:'儿童' })-[:父母]-(n) RETURN n;
MATCH (组织 { NAME:'儿童' })--(n) RETURN n;
match( p1:国家 {NAME:"中国"} )-[rel:隶属关系]-(p2) return p2
match( p1:国家 {NAME:"中国"} )-[rel:隶属关系]-(p2) return p2.NAME
match( p1:省 {NAME:"北京市"} )-[rel:隶属关系]-(p2) return p2
match( p1:省 {NAME:"北京市"} )-[rel:隶属关系]->(p2) return p2
match( p1:省 {NAME:"北京市"} )-[rel:隶属关系]->(p2) return p1,p2
match( p1:国家 {NAME:"中国"} )<-[rel:隶属关系]-(p2) return p1,p2
距离为1到3的关联节点：match(n:国家 {NAME:'中国'})-[*1..2]-(p) return n,p;
 [ ] 括号内n的意义：
            n 距离为n
            ..n 最大距离为n
            n.. 最小距离为n
            m..n 距离在m到n之间

match p=(n:国家 {NAME:'中国'})-[:隶属关系*1..2]-(m) with *,relationships(p) as r return n,m;
match p=(n:国家 {NAME:'中国'})-[*1..2]-(m) with *,relationships(p) as r return n,m;
国家省市区县：match p=(n:国家 {NAME:'中国'})-[:隶属关系*..2]-(m) with *,relationships(p) as r return n,m;
```
### 多标签查询
```
match (n:人:演员) return n;
```
###  通过节点ID查询
```
match (user)-[:主要成就]->(p) where id(user)=71 return p;
MATCH (n) WHERE id(n)=99815 RETURN n;
```
### 多个ID
```
match (user) where id(user) in [2,23] match (user)-[:主要成就]->(p) return p;
```
### 更新节点属性
```
match (user) where id(user) in [2,23] set user.group='ADMINISTRATOR'
```
### 删除节点属性
```
match (user) where id(user) in [2,23] delete user.group;
```

### match子句和create的组合，MERGE子句
```
MERGE (michael:Person { name: 'Michael Douglas' }) RETURN michael;
```

### 统计当前图数据库的节点数量
```
MATCH (n) RETURN count(n);
```
### 统计当前图数据库的关系数量
```
MATCH ()-->() RETURN count(*);
```
### What kind of nodes exist. Sample some nodes, reporting on property and relationship counts per node.
```
MATCH (n) WHERE rand() <= 0.1
RETURN
DISTINCT labels(n),
count(*) AS SampleSize,
avg(size(keys(n))) as Avg_PropertyCount,
min(size(keys(n))) as Min_PropertyCount,
max(size(keys(n))) as Max_PropertyCount,
avg(size( (n)-[]-() ) ) as Avg_RelationshipCount,
min(size( (n)-[]-() ) ) as Min_RelationshipCount,
max(size( (n)-[]-() ) ) as Max_RelationshipCount
```
### What is related, and how
```
CALL db.schema()
```
### List node labels
```
CALL db.labels()
```
### List relationship types
```
CALL db.relationshipTypes()
```
### 查看字段约束与唯一索引
```
Display constraints and indexes
:schema
```
### 查询与周迅有直接关系的明星
```
match m=(:明星 {名称:'周迅'})-[*..1]-() return m;
```
### 查询周迅与王菲的最短路径
```
MATCH p = shortestPath((周迅:明星 {名称:"周迅"})-[*..6]-(王菲:明星 {姓名:"王菲"}))RETURN p;
```
### 查询周迅与王菲的所有最短路径
```
MATCH p = allShortestPaths((周迅:明星 {名称:'周迅'})-[*..6]-(王菲:明星 {姓名:'王菲'})) RETURN p;
MATCH p = allShortestPaths((n:人 {name:'哈良述'})-[*..6]-(m:事 {name:'测试门事件'})) RETURN p;
```
### 查询股票与股东的关系
```
match m=(h:Holder)-->(s:Stock) where s.name=~".*五矿.*" return m;
match m=(h:人)-->(s:事) where s.name=~".*测试门事件.*" return m;
```
### 给已经存在的人添加关系
```
Match (n:Person {id:'erzi'}),(f:Person {id:'bozi'}) Merge (n)-[:fuqi]->(f)
Match (n:人 {name:'哈良述'}),(f:人 {name:'哈革'}) Merge (n)-[:参与相同事件]->(f);
Match (n:人 {name:'哈良述'}),(f:人 {name:'哈革'}) Merge (n)-[:从属相同组织]->(f);
```
### relation修改
```
Match (n:Person ),(f:Person)
where n.id='erzi' and f.id='bozi'
Merge (n)-[r:fuqi]->(f) delete r
Merge (n)-[:FUQI]->(f)
return n,f
```
### 更新属性
```
Match (n:Person {id:'baba'}) set n.name='张三' return n;
备注：
remove和delete都应该与match命令一起使用，
DELETE操作用于删除节点和relation。
REMOVE操作用于删除标签label和属性。
```
### 删除label
```
MATCH (n:Test) remove n:Test
```
### 删除属性
```
Match (n:Person {id:'baba'}) remove n.age return n
```
### 删除与该关系相关的老师和学生及label
```
MATCH (s:Teacher)-[r:teach]->(d:Student) delete r,s,d
```
```
eg. match (n:周永康家族) remove n:周永康家族
eg. Match (n:People) where n.name='周永康' return n
eg. match p=allshortestpaths((n:People {name:'蔡成功'})-[*..6]-(m:People {name:'季昌明'})) return p;
```
### 仅仅删除一个relation
```
Match (a:Person),(b:Person) where a.id='erzi' and b.id='bozi' merge (a)-[r:FUQI]->(b) DELETE r
```
### 排序 order by
```
--降序 MATCH (n:Person) RETURN n order by n.id,n.name desc  LIMIT 25
--正序 MATCH (n:Person) RETURN n order by n.id LIMIT 25
```
### Limit 和 skip
```
Limit : 显示多少行，最前边开始, Skip：跳过前多少行
MATCH (n:Person) RETURN n order by n.id desc skip 2  LIMIT 25
```
### Union 和 union all
```
Union：把多段Match的return结果 上线组合成一个结果集，会自动去掉重复行；
Union all：作用同union，但不去重；
eg. MATCH (n:Person) where n.age>20 RETURN n.id,n.age union all MATCH (n:Person) where n.id='erzi' RETURN n.id,n.age
```
### Null需要注意什么
```
eg. MATCH (n:Person) where n.age>20 RETURN n.id,n.age union all MATCH (n:Person) where n.id='erzi' and n.age is not null  RETURN n.id,n.age
Where 属性 is null or is not null
```
### In语法
```
MATCH (n:Person) where n.age>20 RETURN n.id,n.age union all MATCH (n:Person) where n.id in ['erzi','bozi','baba']  RETURN n.id,n.age
```
### 内置 id
```
Create (a:Person {id:’123’})   //这里的ID是一个属性，和内置ID是两码事
通过函数id(node/relation)可以获取id值
```
### 索引index（根据需要把查询多的字段建索引(create index on :Person(name);)）
```
create index on :Person(id);
drop index on :Person(id);
备注：1.不需要给索引起名称，只需要设置字段即可；2.通过该字段查询都走索引（where、in、substring）
```
### 属性唯一约束  CONSTRAINT（可以给某一属性设置唯一约束）
```
CREATE CONSTRAINT ON (a:Person) ASSERT a.id IS UNIQUE
DROP CONSTRAINT ON (n:人) ASSERT n.name IS UNIQUE
DROP CONSTRAINT ON (n:地) ASSERT n.name IS UNIQUE
DROP CONSTRAINT ON (n:事) ASSERT n.name IS UNIQUE
DROP CONSTRAINT ON (n:物) ASSERT n.name IS UNIQUE
DROP CONSTRAINT ON (n:组织) ASSERT n.name IS UNIQUE
```
### 统计此标签下NODE数量
```
Match (n:Person) return count(*)
```
### 只包含age不为空的node
```
Match (n:Person) return avg(n.age)
```
### shortestPath 查询最短路径
```
match p=shortestPath((n:明星 {名称:'朴树'})-[*..3]-(b:明星 {姓名:'谢霆锋'})) return p
```
### allShortestPaths查询所有最短路径
```
match p=allShortestPaths((n:明星 {名称:'朴树'})-[*..6]-(b:明星 {姓名:'谢霆锋'})) return p
```
### 查任意两个人的关系路径，最短路径（6层关系理论：世界上任何2个人的关系都不超过6层）
```
Match p=allshortestpaths((N:People {name:'蔡成功'})-[*..6]-(m:People  {name:'季昌明'})) return p
```
### 同级LABELS连接
```
MATCH (n:人:虚拟人)  RETURN n union all MATCH (n:人:测试)  RETURN n;
union是会合并相同数据的集合，union all是不合并相同数据的集合
```
### 关系类型统计
```
MATCH ()-[r]->()  RETURN type(r), count(*);
```

### 模糊查询
```
match (n) where n.name=~'.*测试.*' return n;
```
### 通过ID更新关系的属性
```
MATCH ()-[rel]->() WHERE id(rel) IN ids SET rel.foo = data[toString(id(rel))]
```
### 人事组织关系查询：
```
1.MATCH p=(n:人)-[]-(m:事) RETURN p union all MATCH p=(n:人)-[]-(m:组织) RETURN p;
2.MATCH p=(n:组织 {name:'《时代》03全球最具影响力企业家'})-[*..6]-(m:事 {name:'《壮别天涯》扮演角色魔术师'}) RETURN p;
3.MATCH p=(n:组织)-[*..2]-(m:组织) RETURN p;
4.MATCH p=(n:人)-[]-(m:事 {name:'测试事件 '}) RETURN p union all MATCH p=(n:人)-[]-(m:组织 {name:' '}) RETURN p;
5.MATCH p=(n:人)-[*..6]-(m:事 {name:'测试门事件'}) RETURN p union all MATCH p=(n:人)-[]-(m:组织 {name:'测试事件测试'}) RETURN p;
6.MATCH p=(n:人 {name:'哈良述'})-[*..6]-(m:事 {name:'被最高法院下令执行死刑'}) RETURN p;    // 人与事之间如果有关系则会返回结果，没有关系结果返回为空
7.MATCH p=(n:人 {name:'哈良述'})-[*..6]-(m:事 {name:'测试门事件'}) RETURN p union all MATCH p=(n:人 {name:'王飞'})-[*..6]-(m:事 {name:'测试门事件'}) RETURN p;
8.MATCH p=(n:人)-[*1]-(m:事 {name:'测试门事件'}) RETURN p union all MATCH p=(n:人)-[*1]-(m:事 {name:'庆安测试谢阳在测试被打'}) RETURN p union all MATCH p=(n:人)-[*1]-(m:组织 {name:'测试事件测试'}) RETURN p union all MATCH p=(n:人)-[*1]-(m:组织 {name:'庆阳测试被打事件测试'}) RETURN p; // 人、事、组织关系
9.MATCH p=(n:事 {name:'庆安测试谢阳在测试被打'})-[*2]-(m:事 {name:'测试门事件'}) RETURN p; // 事件之间的关系
10.MATCH p=(n:组织 {name:'测试事件测试'})-[*2]-(m:组织 {name:'庆阳测试被打事件测试'}) RETURN p; // 组织之间的关系
11.MATCH p=(n:事 {name:'庆安测试谢阳在测试被打'})-[*2]-(m:组织 {name:'测试事件测试'}) RETURN p; // 事与组织的关系
12.（人员存在参与相同事件与相同组织关系查询）参与事件与从属组织
match p=(n:人 {name:'李方平'})-[:参与事件]-()-[:参与事件]-(m:人 {name:'干卫东'}) return p union all match p=(n:人 {name:'李方平'})-[:从属组织]-()-[:从属组织]-(m:人 {name:'干卫东'}) return p;
13.省/市/区县/街道实体消歧相关查询;
match p=(n:地:区县 {name:'东兰县'})-[:隶属关系]-(f:地:街道)-[:隶属关系]-(m:地:区县 {name:'凤山县'}) return p;
match p=(n:地:区县 {name:'东兰县'})-[:隶属关系]-()-[:隶属关系]-(m:地:区县 {name:'凤山县'}) return p;
```
### 给已存在的节点添加标签
```
match(n {name:'窗含西岭雪8923_572'}) set n:zdr:zdr1:zdr2 return n;
```
### 移除多个标签中的一个标签。（如果节点只包含这个标签则会将这个节点也删除，移除多个标签中的一个则不会）
```
match (n:周永康家族) remove n:周永康家族;
```
### 唯一约束和索引
```
CREATE CONSTRAINT ON (n:人) ASSERT n.name IS UNIQUE;
CREATE CONSTRAINT ON (n:地) ASSERT n.name IS UNIQUE;
CREATE CONSTRAINT ON (n:事) ASSERT n.name IS UNIQUE;
CREATE CONSTRAINT ON (n:物) ASSERT n.name IS UNIQUE;
CREATE CONSTRAINT ON (n:组织) ASSERT n.name IS UNIQUE;
实体名如果存在则更新LABELS和属性，不存在则创建，节点名唯一：
MERGE (n {name:'乖乖小猫咪儿_577'}) set  n:人:zdr:user_1:user_189  RETURN n
union all
MERGE (n {name:'乖乖小猫咪儿_577'}) set  n.test='test'  RETURN n;
MATCH (a {name: '乖乖小猫咪儿_577' }),(b {name: '广西政府官员还在办公室招待吃穿山甲'}) MERGE p=(a)-[r:参与事件 {name:'参与事件'}]->(b) set r.test2='test'  RETURN p;
```

### 人员共同参与事件
```
match p=(n {name:'五岳散人_593'})-[:参与事件]-()-[:参与事件]-(m {name:'鲁国平先生_735'}) return p;
```
### 人员共同加入的组织
```
match p=(n {name:'五岳散人_593'})-[:从属组织]-()-[:从属组织]-(m {name:'殆知阁_591'}) return p;
```

### （name在添加唯一约束之后就已经自动添加了索引）添加索引(在图谱遍历时，快速找到开始节点),大幅提高查询遍历性能
```
CREATE INDEX ON :Actor(name)
添加测试数据：
CREATE (actor:Actor { name:"Tom Hanks" }),(movie:Movie { title:'Sleepless IN Seattle' }),
  (actor)-[:ACTED_IN]->(movie);
使用索引查询:
MATCH (actor:Actor { name: "Tom Hanks" })RETURN actor;
```
### 实体与关系添加时间戳
```
加时间戳的语句match ... where ... with a,bcreate (a)-[:sometype{latesttouch:timestamp()}]->(b)
用最近访问时间作为筛选条件的语句match (a) where ... with a match (a)-[r]-() where timestamp()-r.latesttouch<=5*60*1000
```
### 通过时间过滤
```
match (n:人) where n.insert_time>'1516204700000' and n.insert_time<'1516204900000' return n;
```
### 查询多节点连接的共同节点
```
match (n1)--(m1) where n1.name='测试_781' with m1
match (n2)--(m2) where n2.name='测试_715' and m1=m2 with m2
match (n3)--(m3) where n3.name='测试_609' and m2=m3 with m3 return m3;
match (n1)--(m1) where n1.name='测试_781' with m1
match (n2)--(m2) where n2.name='测试_715' and m1=m2 with m2
match (n3)--(m3) where n3.name='测试_609' and m2=m3 with m3 return count(m3);
match (e:zdr),(f:zdr),(g:zdr)
where e.name='测试_609' and f.name='测试_715' and g.name = '测试_781'
match (n)
match (e)-[r1*1]->(n), (f)-[r2*1]->(n),(g)-[r3*1]->(n)
return r1,r2,r3,n
```
```
match p1=(n1)-[r1*1]->(m), p2=(n2)-[r2*1]->(m),p3=(n3)-[r3*1]->(m) where n1.name='测试_609' and n2.name='测试_715' and n3.name = '测试_781' return p1,p2,p3
```
```
match (e:zdr),(f:zdr),(g:zdr)
where e.name='测试_609' and f.name='测试_715' and g.name = '测试_781'
match (n)
match p1=(e)-[r1*1]->(n), p2=(f)-[r2*1]->(n),p3=(g)-[r3*1]->(n)
return p1,p2,p3
```
```
match (n:人),(m:事)
where n.name=~'.*测试.*' and m.name=~'.*gun.*' and n.sysuser_id='1' and m.user_id='1'
match (e:事),(f:人)
where e.user_id='1' and e.start_time>='2018-02-19 00:00:00' and e.end_time<='2018-05-19 00:00:00' and f.sysuser_id='1'
match p1=(n)-[r1*1]-(e),p2=(m)-[r2*2]-(f)
return p1,p2;
```

### 人员共现的基站
```
match p=(n:人 {name:'XXX_45072219791115644X'})-[r1:手机设备身份码]-()-[r2:访问基站]-()-[r3:访问基站]-()-[r4:手机设备身份码]-(m:人 {name:'XXX_450111197805293913'}) return p limit 100;
```
### 时间过滤基站
```
match p=(n:物 {name:'imei_86022802236371'})-[r:访问基站]-() where r.latelyTime<='2016-04-14 16:54:08' and r.earliestTime>='2016-04-14 16:49:45'  return p;
match p=(n)-[r]-(m) where n.name='bsid_4600078292da2' and n.user_id IS NULL and m.user_id IS NULL and r.realType='1' and r.actionType='0' and r.behaviorType='0' and r.earliestTime<='2016-07-02 20:17:17' and r.latelyTime>='2016-07-02 07:21:00' return p
```
### （聚集分析）查找人员的交叉基站
```
（1）
match (n0),(n1) where n0.name='哈XXX_45072219791115644X' and n1.name='XXX_450111197805293913'
match (n)
match p0=(n0)-[r0:手机设备身份码]-(f0:物)-[e0:访问基站]-(n),p1=(n1)-[r1:手机设备身份码]-(f1:物)-[e1:访问基站]-(n) return p0,p1
（2）
match (n0),(n1) where n0.name='哈良述_45072219791115644X' and n1.name='覃臣寿_450111197805293913'
match (n)
match p0=(n0)-[r0:手机设备身份码]-(f0:物)-[e0:访问基站]-(n),p1=(n1)-[r1:手机设备身份码]-(f1:物)-[e1:访问基站]-(n) return n.name,e0.actionTime,e1.actionTime
```
### 查询存在name属性的节点
```
MATCH (n:人) WHERE exists(n.name) RETURN n;
```
### 批量操作
```
:param events:[{year:2014,id:1},{year:2014,id:2}]
unwind $events as event
merge (y:Year {year:event.year})
merge (y)<-[:IN]-(e:Event {id:event.id})
return e.id as x
order by x
```
### 删除2个NODE之间重复的relationship
```
MATCH (a)-[r:has_test_rel]->(b)
WITH a, b, TAIL (COLLECT (r)) as rr
WHERE size(rr)>0
FOREACH (r IN rr | DELETE r)
```
### 最短路径查询
```
MATCH (ms:Person { name:'Andres' }),(cs:Person { name:'Taylor' }), p = shortestPath((ms)-[r:Follow]-(cs)) RETURN p;
```
### 匹配分页返回
```
MATCH (n) WHERE n.productName='苹果' RETURN n SKIP 10 LIMIT 10
```
### 匹配去重返回
```
MATCH (n) WHERE n.productName='苹果' RETURN DISTINCT n
```
### 别名返回
```
MATCH (n) WHERE n.productName=~'.*苹果.*' RETURN n.productName AS name
```
### 聚合函数中使用distinct来去掉值中重复的数据
```
MATCH (n:`事`) RETURN count(distinct  n.eid);
```
### Collect将所有值收集到一个集合list中
```
MATCH (n:`事`) RETURN collect(n.eid);
```
### 查询结果排序
```
MATCH (n:`事`) RETURN n.eid,id(n) ORDER BY id(n) DESC;
```
### 对聚合结果过滤
```
MATCH (n:`事`)--(m)
WITH m, count(*) AS foaf
WHERE foaf > 100
RETURN m limit 10
```
### 对collect的元素进行排序
```
MATCH (n:事)
WITH n
ORDER BY id(n) DESC LIMIT 30
RETURN collect(id(n))
```
### 在路径搜索的时候限制分支数
```
MATCH (n:事)--(m:虚拟账号ID)
WITH m
ORDER BY id(m) DESC LIMIT 1
MATCH (m)--(o)
RETURN o.name
```
### 实体属性分组统计
```
with [
      {name:'a',sex:'F',country:'CN',age:10},
      {name:'b',sex:'F',country:'CN',age:10},
      {name:'c',sex:'M',country:'CN',age:10},
      {name:'d',sex:'M',country:'US',age:10}
] as p
unwind p as pp
with pp.name as name,pp.sex as sex,pp.country as country,pp.age as age
return sex,country,count(*)
```
### 不包含在列表
```
MATCH (e:Employee)
WHERE not e.id IN [123,124]
RETURN e.id,e.name,e.sal,e.deptno
```
### 属性分组统计
```
MATCH (n:人) RETURN n.eid, count(*)
```
### 如果节点存在，更新或者增加节点属性；如果节点不存在，创建节点，并设置属性
```
MERGE (n:user { id: ‘1’ })
ON CREATE SET n.name= ‘quan’
ON MATCH SET n.name= ‘quan’
```
### 根据一个节点返回关于这个节点的所有信息
```
MATCH (user:User) WHERE user.id = 460
CALL apoc.path.subgraphAll(user, {maxLevel:4}) YIELD nodes, relationships
RETURN nodes, relationships;
```
### 关系没有模式索引所以手动索引在这里非常有用
```
MATCH (:Flight)-[r:DESTINATION]->(:Airport)
CALL apoc.index.addRelationship(r,['taxi_time'])
RETURN count(*)
MATCH (:事)<-[r:命中关键词]-(:虚拟账号ID)
CALL apoc.index.addRelationship(r,['eventTargetIds'])
RETURN count(*)
// Linkedin时间联动添加索引
MATCH ()-[r]-()
CALL apoc.index.addRelationship(r,['start_time'])
RETURN count(*)
备注：3.4版本32766是索引属性值的最大支持长度。
```
### 索引的手动关系不仅根据其属性存储关系，而且还存储开始和结束节点，因此指定的话应该效率更高
```
CALL apoc.index.relationships('DESTINATION','taxi_time:11') YIELD rel, start AS flight, end AS airport
RETURN flight_num.flight_num, airport.name;
```
### 七分钟内到达机场的飞机
```
MATCH (a:Airport {name:'SALT LAKE CITY INTERNATIONAL'})
CALL apoc.index.in(a,'DESTINATION','taxi_time:7') YIELD node AS flight
RETURN flight
```
### 关系过滤
```
MATCH (f:Flight {flight_num:6147})
MATCH (a:Airport {name:'SALT LAKE CITY INTERNATIONAL'})
CALL apoc.index.between(f,'DESTINATION',a,'taxi_time:7') YIELD rel, weight
RETURN *
```
### 替代UNION ALL的参数化查询
```
call db.labels() yield label
call apoc.cypher.run("match p=(n:`"+label+"`)-[]-()-[]-()-[]-()-[]-(m:`"+label+"`) where n.name={a} and m.name={b} return p limit 100", {a:'哈良述测试_3063192_新浪微博',b:'测试测试测试_23314996_新浪微博'}) yield value
return value
```
### 运行 Cypher 语句时间盒（也可以用于防止死锁的发生）
```
call apoc.cypher.runTimeboxed("match (n),(m) match p=shortestPath((n)-[*]-(m)) return p", null, 1000) yield value
return value.p
```
### 实体的二层扩展关系搜索
```
call db.labels() yield label
call apoc.cypher.run("match p=(n:虚拟账号ID)-[]-(f:人)-[]-(g:`"+label+"`)-[]-(h:人)-[]-(m:虚拟账号ID) where n.name={a} and m.name={b} and f.sysuser_id in {c} and h.sysuser_id in {d} and g.start_time>={time1} and g.start_time<={time2} or n.name={a} and m.name={b} and f.sysuser_id in {c} and h.sysuser_id in {d} and g.start_time is null and g.start_time is null return p limit 100",{a:'哈良述测试_3063192_新浪微博',b:'测试测试测试_23314996_新浪微博',c:["3"],d:["3"],time1:'2013-01-13 00:00:00',time2:'2018-07-14 23:59:59'}) yield value
return value.p
```
### 通过关系的属性对返回的关系进行排序
```
MATCH p=(n:虚拟账号ID)-[r:`命中关键词`]->(m:事) RETURN n.name,r.name,id(r),m.name order by id(r) asc  LIMIT 25	// 升序
MATCH p=(n:虚拟账号ID)-[r:`命中关键词`]->(m:事) RETURN n.name,r.name,id(r),m.name order by id(r) desc  LIMIT 25	// 降序
```
### 通过关系的属性对关系进行排序
```
示例属性（属性值是使用逗号分隔的id）
eventTargetIds: 37359837,37359836,36991625,34092505,31546736,29828941,27626850,26211001,26055747
MATCH p=(n:虚拟账号ID)-[r:`命中关键词`]->(m:事 {name:'疫苗'}) where r.eventTargetIds is not null RETURN p order by size(r.eventTargetIds) desc  LIMIT 25
```
### 查看自己当前正在运行的所有查询
```
CALL dbms.listQueries()
```
### 根据id杀掉语句执行的进程
```
CALL dbms.killQueries([‘query-378’,‘query-765’])
```
### 某个节点连接的关系类型以及数量统计
```
MATCH p=(n:领英 {name:'Victoria Ortiz_328455314_linkedin'})-[r]->() RETURN type(r),count(*)
```
### 关系类型别名统计
```
MATCH p=()-[r]->() RETURN type(r) as t,count(*) as c
```
### 关系列表
```
CALL db.relationshipTypes() YIELD relationshipType RETURN relationshipType as result
```
### 标签列表
```
CALL db.labels() YIELD label RETURN label as result
```
### 属性函数过程等列表
```
CALL db.propertyKeys() YIELD propertyKey RETURN propertyKey as result
CALL dbms.functions()
CALL db.schema()
CALL dbms.procedures()
MATCH (n) RETURN count(n)
MATCH ()-->() RETURN count(*);
```

### 根据节点连接的关系数量过滤（注意是数量是不是某种类型）
```
MATCH (n:Item)
WHERE size( (n) – () ) > 10 RETURN n LIMIT 25
```
### 根据节点连接的关系类型数量过滤（注意是数量是不是某种类型）
```
MATCH (n:Item) -[r]- ()
WITH DISTINCT n, type(r) AS relType
WITH n, collect(relType) AS relTypes
WHERE size(relTypes) > 10 RETURN n,relTypes LIMIT 25
```
### 扩展当前节点的二度节点
```
MATCH (n:人:虚拟账号ID:LinkedinID {name:'Matthew Fagnan_233482826_linkedin'})
CALL apoc.path.subgraphAll(n,{maxLevel:2,filterStartNode:true,limit:-1}) YIELD nodes RETURN nodes;
```
### CALL db.labels这个过程结果中移除一个标签
```
CALL db.labels() YIELD label WITH label WHERE label <> 'LabelsTree' AND label <> 'LinkedinID'
CALL apoc.cypher.run("MATCH (n:`"+label+"`) RETURN labels(n) AS label,COUNT(n) AS count",null) YIELD value
RETURN value.label AS label,value.count AS count
```
### 查不存在关系的两个独立节点
```
match (n) , (m)
where not n-[ * ]-(m)
return n,m
limit 10
```
### 为已经创建好的节点指定Label
```
match(n) set n:Label
```
### 删除属性
```
MATCH ()-[r]-() REMOVE r.dateHistory
MATCH (n:人)  WHERE n.name CONTAINS '上官娜兰_03' REMOVE n.sysuser_id
```
### 使用pageRank计算得分对节点影响力进行排序
```
MATCH (n:人)
WITH collect(n) as nodes
CALL apoc.algo.pageRank(nodes) YIELD node,score
RETURN node.name,score
ORDER BY score DESC
```
### 对指定关系类型的节点运行pageRank计算
```
MATCH (n:人)
WITH collect(n) as nodes
CALL apoc.algo.pageRankWithConfig(nodes,{types:'手机号|通联'}) YIELD node,score
RETURN node.name,score
ORDER BY score DESC
```
### pageRank指定关系类型后执行十个页面级别的迭代
```
MATCH (n:人)
WITH collect(n) as nodes
CALL apoc.algo.pageRankWithConfig(nodes,{iterations:10,types:'通联'}) YIELD node,score
RETURN node.name,score
ORDER BY score DESC
```
### 按结点的标签：只经过标签为“A”的结点
```
match p=shortestPath((m:Person{name:'1'})-[r:A*..4]-(n:Person{name:'4'})) return p;
```
### 按结点的属性：不经过name为'5'的结点
```
match p=shortestPath((m:Person{name:'1'})-[r*1..4]-(n:Person{name:'4'}))
where all(x in nodes(p) where x.name<>'5')
return p;
```
### 按关系的属性：只经过那些属性f小于4的关系
```
match p=shortestPath((m:Person{name:'1'})-[r*1..4]-(n:Person{name:'4'}))
where all(x in r where x.f<4) return p;
```
### 多值模糊查询，使用explain查看相对于OR的优势
```
match (n:Label) where n.attr =~ '.*a1.*|.*a2.*' return n
```
### 查看语句的执行计划EXPlAIN /PROFILE
```
EXPlAIN MATCH (n:现实人员) RETURN count(n)
```
### 平均AVG/MAX/MIN
```
MATCH (n:现实人员)
RETURN avg(n.influenceScore)
```
### CSV文件的导入
```
LOAD CSV WITH HEADERS FROM ‘file://person.csv’ AS line
CREATE (:person {关系人名称:line[1],股票代码:line[2],股票名称:line[3],职务:line[4]})
```
### 关系或查询
```
(a)-[r:TYPE1|TYPE2]->(b)
```
### 标签或查询
```
match (n:A) match (m:B) return n,m
```
### 排除一个标签
```
match (a:IP {name:'223.104.33.80'})--(b) where not b:QQ账号 return *
```
### 查询多个标签
```
match (b) where  b:QQ账号 OR b:微信账号 return b
```
### 标签类型数量统计
```
call db.labels() yield label return count(label) as count
MATCH (n) with labels(n) as lab return count(DISTINCT lab
```
### 计算结点的出入度
```
MATCH (p:LinkedinID)
WITH p, size ((p) -[]-> ()) AS outDegree, size ((p) <-[]- ()) AS inDegree
WHERE inDegree > 5 AND outDegree > 5
RETURN p limit 1
```
### 排除掉多个标签
```
CALL db.labels() YIELD label WITH label WHERE label <> 'Label1' AND  label <> 'Label2' AND label <> 'Label3' RETURN label
```
### 最短路径-无条件
```
match p=shortestPath((m:Person{name:'1'})-[r*1..4]-(n:Person{name:'4'}))  return p
```
### 最短路径-按节点的标签：只经过标签为"A"的节点
```
match p=shortestPath((m:Person{name:'1'})-[r:A*..4]-(n:Person{name:'4'})) return p
```
### 最短路径-按节点的属性：不经过name为'5'的结点
```
match p=shortestPath((m:Person{name:'1'})-[r*1..4]-(n:Person{name:'4'}))
where all(x in nodes(p) where x.name<>'5') return p
```
### 最短路径-按关系的属性：只经过那些属性f小于4的关系
```
match p=shortestPath((m:Person{name:'1'})-[r*1..4]-(n:Person{name:'4'}))
where all(x in r where x.f<4) return p
```
### 最短路径-求多个结点两两间的最短路径
```
使用with定义一个列表变量，里面是所有的点；
使用match匹配出所有的结点，将结点放到列表中，注意这里列表中的元素是结点类型，上面是业务id；
使用两个unwind再次将结点列表打散到行，之前提到过两个unwind的结点也是以笛卡尔积的方式返回的（看这篇博客），所以这里是两两的任意组合，甚至两个结点相同的组合，实际上我们这里求最短路径1到2和2到1肯定是一样的，所以用id(source)<id(target)来去除一半；
最后是shortestPath函数，里面的source,target就是前面的组合；
10，11，14，13，18，19
with [3105, 200025928, 200025929, 151286502, 135660351] as id_list
match (v:vertices) where v.id in id_list
  with collect(v) as nodes
  unwind nodes as source
  unwind nodes as target
  with source,target where id(source)<id(target)
match paths = shortestPath((source)-[:HOLDER|MANAGER*0..2]-(target)) where all(x in nodes(paths) where x.id<>3105)
  with paths limit 20000
  return paths
```
```
with [10,11,14,15,17,18,23,1,321,123,123,123,12,213,123,123,123,213,123,1321] as id_list
match (v:人:虚拟账号ID:LinkedinID) where id(v) in id_list
  with collect(v) as nodes
  unwind nodes as source
  unwind nodes as target
  with source,target where id(source)<id(target)
match paths = allShortestPaths((source)-[*..6]-(target)) with paths limit 100
  return paths
```
```
优化查询：
PROFILE WITH [2842,18446,51149,63373,87863,101324,230869,25,69710] AS id_list
MATCH (v) WHERE id(v) IN id_list
  WITH collect(v) AS nodes
  UNWIND nodes AS source
  UNWIND nodes AS target
  WITH source,target WHERE id(source)<id(target)
MATCH paths = (source)-[*..3]-(n)-[*..3]-(target) WHERE id(n)=1557 WITH paths LIMIT 10
  RETURN paths
```
### 笛卡尔积-展开两个列表其结果为笛卡尔积
```
unwind [1,2,3,4] as x
unwind ['a','b','c','d'] as y
return x,y
```
### 笛卡尔积-多个with子查询的结果会以笛卡尔积的方式形成最终查询的结果
```
match (m:vertices) where m.id in [111,222,333]
with m
match (m:vertices) where m.id in [444,555,666]
with m,n
return m,n
```
### 笛卡尔积-match中的多个变量也是以笛卡尔积形式返回
```
match (m:vertices:{type:'a'}),(n:vertices{type:'b'}) return n;
```
### 最短路径分析
```
MATCH p=allShortestPaths((m:Link {name:'Alan'})-[*..6]-(n:Link {name:'Antonio'}))
WHERE all(x in nodes(p) where id(x)=1231) return p LIMIT  10
这种类似的查询有没有更好的写法？
（1）可以使用neo4j图算法库的方法（需要先安装graph algorithm 的plugin
）：
用The Dijkstra Shortest Path algorithm :
MATCH (start:Loc{name:'A'}), (end:Loc{name:'F'})
CALL algo.shortestPath.stream(start, end, 'cost')
YIELD nodeId, cost
MATCH (other:Loc) WHERE id(other) = nodeId
RETURN other.name AS name, cost
（2）也可以把结果写回：
MATCH (start:Loc{name:'A'}), (end:Loc{name:'F'})
CALL algo.shortestPath(start, end, 'cost',{write:true,writeProperty:'sssp'})
YIELD writeMillis,loadMillis,nodeCount, totalCost
RETURN writeMillis,loadMillis,nodeCount,totalCost
```
### 输出 一条路径上的所有关系？
```
apoc.path.subgraphAll(startNode <id>Node/list, {maxLevel, relationshipFilter, labelFilter, bfs:true, filterStartNode:true, limit:-1}) yield nodes, relationships
```
### 查询A发展或推荐了哪些人要查询三度
```
MATCH (a)-[:发展|推荐*0...2]->(c) RETURN c;
```
### 两两共同关系节点
```
PROFILE WITH [62677,230869,87863] AS id_list
MATCH (v) WHERE id(v) IN id_list
 WITH collect(v) AS nodes
 UNWIND nodes AS source
 UNWIND nodes AS target
 WITH source,target WHERE id(source)<id(target)
MATCH paths=(source)--(n)--(target)
WITH paths LIMIT 100
RETURN paths
```
### FOREACH
```
为所有节点设置mark属性：
MATCH p =(begin)-[*]->(END )
WHERE begin.name='A' AND END .name='D'
FOREACH (n IN nodes(p)| SET n.marked = TRUE )
```
### 时间转换
```
RETURN apoc.date.format(timestamp())
```
### 寻找一条最短路径并统计层数深度
### 节点的属性做全文检索用apoc目前支持的可以满足需求，但是我现在要对关系的属性做全文检索，那有没有什么其它办法满足需求呢，能否给个示例？
```
CALL apoc.index.relationships(‘关注’,'headline:"position of Director* " ’ ) YIELD rel, start AS startNode, end AS endNode RETURN rel
```
### 跳过删除
```
MATCH (n:Employee {name: “Govind Singh”})
WITH n
SKIP 1
DELETE n
```
### 逻辑查询
```
MATCH (a1:A{name:"A1"}), (a2:A{name:"A2"}), (a3:A{name:"A3"}), (a4:A{name:"A4"})
UNWIND [a1, a2, a3, a4] as a
MATCH (w:W)-[:WRITES]->(a)
WITH a1, a2, a3, a4, w, collect(a) as connectedNodes
WITH w, CASE WHEN a1 in connectedNodes THEN a1 ELSE null END as a1,
        CASE WHEN a2 in connectedNodes THEN a2 ELSE null END as a2,
        CASE WHEN a3 in connectedNodes THEN a3 ELSE null END as a3,
        CASE WHEN a4 in connectedNodes THEN a4 ELSE null END as a4
RETURN w, a1, a2, a3, a4
```

### 同时经过两个关系（*2表示经过两个关系，*1表示经过一个关系）-（关系与查询方式）
```
MATCH p=(n)-[r1:发帖]-()-[r2:点赞|:评论*2]-(m) WHERE id(n)=3194400 RETURN p LIMIT 100
```
### 合并属性
```
MERGE (n:Node {id: 'argan'})
SET n += {id: 'argan', age: 30, sex: 'male', email: 'arganzheng@gmail.com'}
RETURN n
```
### 标签统计
```
UNWIND [{label:'LabelsTree'},{label:'LinkedinID'}] AS row
CALL apoc.cypher.run("MATCH (n:`"+row.label+"`) RETURN '"+row.label+"' AS label,COUNT(n) AS count",null) YIELD value
RETURN value.label AS label,value.count AS count
【返回值与UNWIND后的列表索引位对应即可，不要加返回字符串影响效率】
UNWIND [{label:'LinkedinID'},{label:'LabelsTree'}] AS row
CALL apoc.cypher.run("MATCH (n:`"+row.label+"`) RETURN COUNT(n) AS count",null) YIELD value
RETURN value.count AS count
```
### where条件如何能查询不存在某属性的node节点
```
MATCH (p:person) WHERE  p.gender is null return p limit 10
match (p:Person) where not exists(p.gender) return p limit 10;
```
### 查询标签下所有节点的属性
```
MATCH (n:LinkedinID) RETURN keys(n) AS key LIMIT 10
```
### 根据节点属性KEY的数量排序
```
MATCH (n:LinkedinID) RETURN keys(n) AS key ORDER BY SIZE(key) DESC LIMIT 100
```
### 快速统计节点的关系数（节点的关系计数器）
```
MATCH (n:Person {name:‘Keanu Reeves’})
RETURN size((n)-[]-())
```
### 数据过滤
```
MATCH (n) WHERE id(n)=34627 RETURN filter(x IN labels(n) WHERE x <> '公司') AS labels
MATCH (n) WHERE id(n)=34627 RETURN labels(n),filter(x IN labels(n) WHERE x <> '公司')
```
### 返回路径的长度
```
MATCH p=shortestPath((n)-[*..6]-(m)) WHERE id(n)=115160 AND id(m)=35 RETURN size(relationships(p)) AS size
```
### 两两之间关系查询
```
WITH [518883,518882,518884,0] AS ids
MATCH (n) WHERE id(n) IN ids
WITH collect(n) AS nodes
UNWIND nodes AS source
UNWIND nodes AS target
WITH source,target WHERE id(source)<id(target)
MATCH path=(source)-[:家庭成员]-()-[:家庭成员]-(target) RETURN path
```
### 多人共同关系分析
```
MATCH (n0),(n1),(n2) WHERE id(n0)=275014 AND id(n1)=17247 AND id(n2)=45063  MATCH (n) WHERE zdr.apoc.relatCalculateRestrict(labels(n),labels(n),'LinkedinID||FacebookID||TwitterID||现实人员||志愿机构||组织||认证机构||学校||公司||颁发机构||其它组织')=true MATCH p0=(n0)-[r0]-(n),p1=(n1)-[r1]-(n),p2=(n2)-[r2]-(n) RETURN p0,p1,p2
```
### 多人两两关系分析
### 查询孤立节点
```
match (n) where not (n)–() return id(n);
```
### 批量删除节点
```
CALL apoc.periodic.iterate(‘MATCH ()-[n:作者]->() RETURN n’,‘WITH {n} AS m DELETE m’,{batchSize:10000,parallel:false});
```
### neo4j重置密码
```
（1）
进入neo4j自身提供的可视化界面，输入： :server change-password，即可修改。
（2）
删除 data/dbms/auth 文件然后重新启动 。
windows:C:\Users\pangg_000\Documents\Neo4j\default.graphdb\dbms
 (3)CYPHER-SHELL修改密码（bin/cypher-shell）
CALL dbms.changePassword('123456');	// 修改密码
```
### 寻找现实人员之间的关系
```
MATCH (n:`现实人员`) WITH collect(id(n)) AS ids
with ids as id_list
match (v) where id(v) in id_list
with collect(v) as nodes
unwind nodes as source
unwind nodes as target
with source,target where id(source)<id(target)
match paths = allShortestPaths((source)-[*..6]-(target))
with paths limit 10 return paths
```
### UNWIND-MERGE
```
UNWIND [ {  year : 2014, id : 1}, {year : 2014, id : 2 } ] AS event
MERGE (y:Year { year: event.year })
MERGE (y)<-[:IN]-(e:Event { id: event.id })
RETURN e.id AS x
ORDER BY x
```
### 远程加载CSV文件
```
LOAD CSV FROM "http://data.neo4j.com/examples/person.csv" AS line
MERGE (n:Person {id: toInt(line[0])})
SET n.name = line[1]
RETURN n
```
```
LOAD CSV FROM "http://localhost:8000/neo-csv/test.csv" AS line
MERGE (n:Person {id: toInt(line[0])})
SET n.name = line[1]
RETURN n
```
### 时间函数
```
MATCH (n:专题事件) SET n.update_time_date=apoc.date.format(timestamp(),'ms','yyyy-MM-dd HH:mm:ss','CTT') return n.update_time_date
```
### 修改关系类型
```
MATCH (n:重点人组织)<-[r:`从属组织`]-(m)
MERGE (n)<-[r2:`参与组织`]-(m)
SET r2.name='参与组织'
DELETE r
RETURN count(*)
```
### 指定服务登录：bin/cypher-shell -a localhost:7688 -u neo4j -p 123456

### 查询叶子节点
```
MATCH (n:LabelsTree) WHERE NOT (n)-->() RETURN DISTINCT n.labelName
```
### 统计每种标签下节点的个数
```
一、CALL db.labels() YIELD label WITH label
CALL apoc.cypher.run("MATCH (n:`"+label+"`) RETURN count(n) AS count",null) YIELD value RETURN value
二、UNWIND [{label:'新闻'},{label:'现实人员'}] AS row
CALL apoc.cypher.run("MATCH (n:`"+row.label+"`) RETURN '"+row.label+"' AS label,COUNT(n) AS count",null) YIELD value
RETURN value.label AS label,value.count AS count
```
### 缓存预热
```
Warm the cache to improve performance from cold start
CALL apoc.warmup.run()
```
### 数据导出为JSON文件，生成的JSON在neo4j安装目录下的import目录下
```
CALL apoc.export.json.query('match (n) return n limit 10','test.json')
```
### 将整个库导出到指定的JSON文件
```
CALL apoc.export.json.all('all.json',null)
```
### 将指定的节点和关系导出到指定的JSON文件
```
MATCH (nod)
MATCH ()-[reels]->()
 WITH collect(nod) as node, collect(reels) as rels
CALL apoc.export.json.data(node, rels, {file}, null)
YIELD nodes, relationships, properties, file, source,format, time
RETURN *
```
### 导出图对象
```
CALL apoc.graph.fromDB('test',{}) yield graph
CALL apoc.export.json.graph(graph, 'garph.json')
YIELD nodes, relationships, properties, file, source,format, time
RETURN *
```
### 给节点n设置json属性
```
CREATE (n) WITH n CALL apoc.convert.setJsonProperty(n, 'json', [1,2,3]) RETURN n
```
### 从CYPHER直接生成JSON【支持节点转换/属性转换/路径转换】
```
match (n) return casia.convert.json(n) limit 10
match p=(n)--() return casia.convert.json(p) limit 1
match (n) return casia.convert.json(properties(n)) limit 10
```

### 批量修改：
```
CALL apoc.periodic.iterate(
'MATCH (n:专题事件)<-[r:`命中关键词`]-(m) RETURN n,r,m',
'WITH {n} AS n,{r} AS r,{m} AS m MERGE (n)<-[r2:`参与事件`]-(m) SET r2.name="参与事件" DELETE r',{batchSize:1000,parallel:false});
```
### 3.5.x执行cql文件
```
type build.cql | bin\cypher-shell.bat -a localhost -u neo4j -p 123456
```
```
cat build.cql | bin\cypher-shell.bat -a localhost -u neo4j -p 123456
```
### 搬运节点
```
MERGE (n:Node {id: 'argan'})
SET n += {id: 'argan', age: 30, sex: 'male', email: 'arganzheng@gmail.com'},n:Test:Test2
RETURN n;
```
### 删除重复数据
```
MATCH (n:新浪微博ID) WITH n.name AS name,count(n) AS count ORDER BY count DESC
WITH CASE WHEN count>=2
 THEN name
 ELSE NULL
 END AS name
WITH name
MATCH (n:新浪微博ID) WHERE n.name=name OPTIONAL MATCH (n)-[r]-() DELETE n,r;
DROP INDEX ON:新浪微博ID(name);
CREATE CONSTRAINT ON (n:新浪微博ID) ASSERT n.name IS UNIQUE;
```
### apoc 有json转map对象
```
apoc 3.5
//apoc.convert.fromJsonList   转jsonArray
with apoc.convert.fromJsonList('[{"nodeId":"ec4ce2ce-2626-11ea-ad00-0242ac1e4105"}]')  as value
return value[0].nodeId
//apoc.convert.fromJsonMap	转jsonObject
with apoc.convert.fromJsonMap('{"nodeId":"ec4ce2ce-2626-11ea-ad00-0242ac1e4105"}')  as value
return value.nodeId
```
### neo4j 实现分组查询，每组返回前10个
```
match (from)-[r]->(to)
where from.id in [1,2,3]
WITH from,r,to
ORDER BY r.age DESC
WITH from, collect( r )[0…5] AS rel
RETURN from, rel
```
### 高效获取统计数据
```
CALL apoc.meta.stats() YIELD stats RETURN stats
CALL apoc.meta.stats() YIELD labels RETURN labels.Person as personCount
CALL apoc.meta.stats() YIELD labels RETURN labels {.Person, .Movie, .Director} as counts
```
### 批量更新
```
CALL apoc.periodic.iterate('MATCH (n) RETURN n','WITH {n} AS m SET m.name=m.nameNodeSpace',{batchSize:10000,parallel:false});
```
### cypher foreach的使用
```
// 将设置路径上所有的节点的 flag 属性为 true
match p = (begin) -[*]-> (end)
where begin.name='a' and end.name = 'z'
foreach (n in nodes(p)  |  set n.flag = true )
// 将列表中的人全部加为 朋友
match (a:User)
where a.userId = 1
foreach ( name in ['a','b','c']  |  create (a) --> (:User{name:name}) )
```
### 删除双向关系
```
MATCH p=(n)-[r1:关注]->(m)-[r2:关注]->(n) SET r1.markFcous=1,r2.markFcous=2;
MATCH (n)-[r:关注]-(m) WHERE r.markFcous=2 DELETE r;
```
### 查询多个标签的数据
```
match (n) where any(label in labels(n) WHERE label in ['A 标签', 'B 标签']) return n
```
### 时间戳函数
```
return apoc.date.format(timestamp(),'ms','yyyyMMddHHmmss','CTT') as createTime
```
### 关系索引ss
```
直接找边  apoc.index.relationships('TYPE','prop:value*')
  CALL apoc.index.relationships('DESTINATION','taxi_time:11') YIELD rel, start AS flight, end AS airport
  RETURN flight_num.flight_num, airport.name;
  绑定入关系  关系指向node    apoc.index.in(node,'TYPE','prop:value*')
  绑定出关系  关系不指向node     apoc.index.out(node,'TYPE','prop:value*')
  绑定两头   apoc.index.between(node1,'TYPE',node2,'prop:value*')
  MATCH (f:Person {person_nk:"215")
  CALL apoc.index.out(f,'SUPERVISOR','current_flag:Y') YIELD rel, weight
  RETURN * limit 10;
```
### 有权最短路径
```
http://neo4j.com.cn/topic/5b02c1899662eee704f31d00
MATCH (start:Point {title: ‘Some Point 1’}), (end:Point {title: ‘Some Point 5’})
MATCH p=(start)-[:distance*]->(end)
WITH p,reduce(s = 0, r IN rels( p) | s + r.value) AS dist
RETURN p, dist ORDER BY dist DESC
MATCH (start:Point {title: ‘Some Point 1’}), (end:Point {title: ‘Some Point 5’})
CALL apoc.algo.dijkstra(start, end, ‘distance’, ‘value’) YIELD path, weight
RETURN path, weight
```
### 查看集群成员角色和请求路由信息
```
call dbms.cluster.overview()
call dbms.cluster.routing.getServers()
```
```
CURL命令行操作：
curl -D - -H "Accept:application/json" "http://localhost:7474/db/data/"
curl -D - -H "Accept:application/json" -H "X-Stream:true" "http://localhost:7474/db/data/"
HTTP/1.1 401 Unauthorized
Date: Mon, 26 Feb 2018 09:35:24 GMT
Content-Type: application/json; charset=UTF-8
WWW-Authenticate: Basic realm="Neo4j"
Content-Length: 138
Server: Jetty(9.2.22.v20170606)
{
  "errors" : [ {
    "code" : "Neo.ClientError.Security.Unauthorized",
    "message" : "No authentication header supplied."
  } ]
}
```
```
服务器相应端口开放（开放服务端端口）：
firewall-cmd --zone=public --permanent --add-port=7474/tcp
firewall-cmd --reload #一定不要忘记这句话
firewall-cmd --list-ports # 查看端口是否打开成功
```
```
neo4j为我们提供了REST方式来访问数据库服务，这里我们使用JERSEY作为REST 客户端：
http://blog.csdn.net/yidian815/article/details/12887259
```
```
Ne04j图数据库访问的三种方式：1.JDBC数据库驱动访问；2.Rest API访问；3.嵌入式访问。
```
```
Neo4j LINUX启动：https://neo4j.com/download-thanks-beta/?edition=community&release=3.4.0-alpha08&flavour=unix&_ga=2.219638171.368476066.1519631263-83949751.1517212122
```
### 装图数据库
```
1.安装包解压：
tar -zxvf neo4j_*.tar.gz
2.配置数据库路径替换默认的graph.db
3.neo4j 开启远程web访问7474端口:
在安装目录的 $NEO4J_HOME/conf/neo4j.conf 文件内，找到下面一行，将注释#号去掉就可以了 dbms.connectors.default_listen_address=0.0.0.0
4.启动图数据库：
控制台运行：bin/neo4j console
后台进程运行：bin/neo4j start
5.默认用户名与密码都是：neo4j	修改的密码：123456
Windows添加环境变量之后以service形式启动：
新建
Path追加
参考cypher查询：https://www.jianshu.com/p/2bb98c81d8ee
6.linux控制台实时打印日志
tailf knowledge-graph.log
五角星注释
// ★★★★★--EXECUTE METHOD TO RUN
// ☆☆☆☆☆--MUST TO BE SET
【neo4j全文检索】https://blog.csdn.net/weixin_42348333/article/details/89816699
【neo4j官方文档】https://neo4j.com/docs/cypher-manual/3.5/schema/index/#schema-index-fulltext-search
```

### 多标签添加
```
WITH '["Ha","Kfs","Stb"]' AS string
WITH apoc.convert.fromJsonList(string) AS jsonArray
MERGE (n:Test {name:'test0917'}) WITH n,jsonArray
CALL apoc.create.addLabels(n,jsonArray) YIELD node RETURN node
```

### 批量多标签添加【节点打标签脚本配置】
```
CALL apoc.periodic.iterate('CALL apoc.load.jdbc(\'jdbc:mysql://datalab-contentdb-dev.crkldnwcom.cn:3306/master_dev?user=test&password=test&useUnicode=true&characterEncoding=utf8&serverTimezone=UTC\', \'SELECT name_cn FROM table WHERE id=151585872\')','WITH apoc.convert.fromJsonList(row.name_cn) AS jsonArray MATCH (n:Test {name:\'test091ss7\'}) WITH n,jsonArray CALL apoc.create.addLabels(n,jsonArray) YIELD node RETURN node', {parallel:false,batchSize:1000}) YIELD batches,total,timeTaken,committedOperations,failedOperations,failedBatches,retries,errorMessages,batch,operations RETURN batches,total,timeTaken,committedOperations,failedOperations,failedBatches,retries,errorMessages,batch,operations
```
```
WITH n,row CALL apoc.create.addLabels(n,apoc.convert.fromJsonList(row.src)) YIELD node RETURN node
```

### 命令行执行CYPHER
```
bin/cypher-shell -u neo4j -p datalab%pro --format plain 'MATCH (n) RETURN n LIMIT 10'
```

### 获取24H之前的系统时间
```
RETURN apoc.date.format(apoc.date.add(timestamp(), 'ms', -1, 'd'))
```

### 获取时间戳
```
RETURN TOINTEGER(apoc.date.format(timestamp(),'ms','yyyyMMddHHmmss','CTT')) AS createTime
RETURN TOINTEGER(apoc.date.format(apoc.date.add(timestamp(), 'ms', -1, 'd'),'ms','yyyyMMddHHmmss','CTT')) AS createTime
```
### CYPHER实现ONGDB_CHECK_POINT的获取和更新【构建节点任务获取CHECK_POINT】【构建关系任务获取和更新CHECK_POINT】
```
- 获取检查点
CALL apoc.load.jdbcParams('jdbc:mysql://datalab-contentdb-dev.crkldnwly6ki.rds.cn-north-1.amazonaws.com.cn:3306/database?user=dev&password=datalabgogo&useUnicode=true&characterEncoding=utf8&serverTimezone=UTC','SELECT check_point FROM ONGDB_TASK_CHECK_POINT WHERE hcode=?',['HGRAPHTASK(HORGGuaranteeV001)-[担保]->(HORGGuaranteeV001)']) YIELD row RETURN row.check_point AS check_point
- 更新检查点
CALL apoc.load.jdbcUpdate('jdbc:mysql://datalab-contentdb-dev.crkldnwly6ki.rds.cn-north-1.amazonaws.com.cn:3306/database?user=dev&password=datalabgogo&useUnicode=true&characterEncoding=utf8&serverTimezone=UTC','UPDATE ONGDB_TASK_CHECK_POINT SET check_point=? WHERE hcode=?',['1900-01-01 23:59:59','HGRAPHTASK(HORGGuaranteeV001)-[担保]->(HORGGuaranteeV001)'])
```


